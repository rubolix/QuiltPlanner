<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>QuiltPlanner Tests</title>
<style>
body { font-family: monospace; background: #faf8f5; color: #3a3632; padding: 20px; max-width: 800px; margin: 0 auto; }
h2 { color: #5b8a8a; margin-top: 24px; }
.pass { color: #4a8c5c; } .fail { color: #c0392b; font-weight: bold; }
.summary { font-size: 1.2rem; margin-top: 20px; padding: 12px; border-radius: 6px; }
.summary.ok { background: #e8f5e9; color: #2e7d32; }
.summary.bad { background: #fce4ec; color: #c62828; }
</style>
</head>
<body>
<h1>ğŸ§µ QuiltPlanner Test Suite</h1>
<div id="output"></div>
<script>
let passed = 0, failed = 0;
const out = document.getElementById('output');

function section(name) {
  out.innerHTML += `<h2>${name}</h2>`;
}

function assert(condition, msg) {
  if (condition) {
    passed++;
    out.innerHTML += `<div class="pass">  âœ… ${msg}</div>`;
  } else {
    failed++;
    out.innerHTML += `<div class="fail">  âŒ FAIL: ${msg}</div>`;
  }
}

function assertEq(actual, expected, msg) {
  assert(actual === expected, `${msg} (expected ${expected}, got ${actual})`);
}

function assertClose(actual, expected, tol, msg) {
  assert(Math.abs(actual - expected) < tol, `${msg} (expected ~${expected}, got ${actual})`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Inline copies of pure functions to test
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function fmtDim(v) {
  const whole = Math.floor(v);
  const frac = v - whole;
  const fracs = [[0.125,'â…›'],[0.25,'Â¼'],[0.375,'â…œ'],[0.5,'Â½'],[0.625,'â…'],[0.75,'Â¾'],[0.875,'â…']];
  if (Math.abs(frac) < 0.01) return `${whole}`;
  for (const [val, sym] of fracs) {
    if (Math.abs(frac - val) < 0.01) return whole > 0 ? `${whole}${sym}` : sym;
  }
  return v.toFixed(2);
}

function yardsToFraction(yards) {
  const eighths = Math.ceil(yards * 8);
  const whole = Math.floor(eighths / 8);
  const rem = eighths % 8;
  const fracs = ['','â…›','Â¼','â…œ','Â½','â…','Â¾','â…'];
  if (rem === 0) return `${whole}`;
  return whole > 0 ? `${whole} ${fracs[rem]}` : fracs[rem];
}

function cutSize(piece, seam) {
  const s = seam;
  switch (piece.type) {
    case 'square':
      return { w: piece.finW + 2*s, h: piece.finW + 2*s };
    case 'rect':
      return { w: piece.finW + 2*s, h: piece.finH + 2*s };
    case 'hst': {
      const hstCut = piece.finW + 0.875;
      return { w: hstCut, h: hstCut, yieldsTwo: true };
    }
    case 'qst': {
      const qstCut = piece.finW + 1.25;
      return { w: qstCut, h: qstCut, yieldsFour: true };
    }
    case 'flygeese': {
      const fgLg = piece.finW + 1.25;
      const fgSm = piece.finH + 0.875;
      return { w: fgLg, h: fgLg, smallW: fgSm, smallH: fgSm, yieldsFour: true };
    }
    case 'strip': {
      return { w: piece.finW + 2*s, h: piece.finH + 2*s, isStrip: true };
    }
    case 'circle': {
      const diam = piece.finW + 0.75;
      return { w: diam, h: diam };
    }
    default:
      return { w: piece.finW + 2*s, h: piece.finW + 2*s };
  }
}

function calcGrid(quiltW, quiltH, blockSz, borderW, sashW) {
  const innerW = quiltW - 2 * borderW;
  const innerH = quiltH - 2 * borderW;
  const cols = Math.max(1, Math.floor((innerW + sashW) / (blockSz + sashW)));
  const rows = Math.max(1, Math.floor((innerH + sashW) / (blockSz + sashW)));
  return { rows, cols, total: rows * cols };
}

function calcStripsNeeded(count, cutW, wof) {
  const acrossWOF = Math.max(1, Math.floor(wof / cutW));
  return Math.ceil(count / acrossWOF);
}

function calcBacking(quiltW, quiltH, wof) {
  const backW = quiltW + 8, backH = quiltH + 8;
  const panels = backW <= wof ? 1 : Math.ceil(backW / wof);
  return Math.ceil(((backH * panels) / 36) * 8) / 8;
}

function calcBinding(quiltW, quiltH, wof, bindingW) {
  const perimeter = 2 * (quiltW + quiltH) + 12;
  return Math.ceil(perimeter / wof);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TESTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

section('ğŸ“ fmtDim â€” Dimension Formatting');
assertEq(fmtDim(3), '3', '3 â†’ "3"');
assertEq(fmtDim(3.5), '3Â½', '3.5 â†’ "3Â½"');
assertEq(fmtDim(3.25), '3Â¼', '3.25 â†’ "3Â¼"');
assertEq(fmtDim(3.75), '3Â¾', '3.75 â†’ "3Â¾"');
assertEq(fmtDim(3.125), '3â…›', '3.125 â†’ "3â…›"');
assertEq(fmtDim(3.875), '3â…', '3.875 â†’ "3â…"');
assertEq(fmtDim(0.25), 'Â¼', '0.25 â†’ "Â¼" (no leading 0)');
assertEq(fmtDim(0.5), 'Â½', '0.5 â†’ "Â½"');
assertEq(fmtDim(0), '0', '0 â†’ "0"');
assertEq(fmtDim(12), '12', '12 â†’ "12"');

section('ğŸ“ yardsToFraction â€” Yardage Rounding');
assertEq(yardsToFraction(1), '1', '1 yard');
assertEq(yardsToFraction(2), '2', '2 yards');
assertEq(yardsToFraction(0.125), 'â…›', 'â…› yard');
assertEq(yardsToFraction(0.5), 'Â½', 'Â½ yard');
assertEq(yardsToFraction(1.5), '1 Â½', '1Â½ yards');
assertEq(yardsToFraction(2.25), '2 Â¼', '2Â¼ yards');
assertEq(yardsToFraction(0.3), 'â…œ', '0.3 rounds up to â…œ');
assertEq(yardsToFraction(0.01), 'â…›', 'Tiny amount rounds up to â…›');
assertEq(yardsToFraction(0), '0', '0 yards');

section('âœ‚ï¸ cutSize â€” Square Piece');
let cs = cutSize({ type: 'square', finW: 3 }, 0.25);
assertClose(cs.w, 3.5, 0.01, 'Square 3â€³ + Â¼â€³ seam = 3Â½â€³ cut');
assertClose(cs.h, 3.5, 0.01, 'Square height matches width');

cs = cutSize({ type: 'square', finW: 6 }, 0.25);
assertClose(cs.w, 6.5, 0.01, 'Square 6â€³ + Â¼â€³ seam = 6Â½â€³ cut');

cs = cutSize({ type: 'square', finW: 2 }, 0.5);
assertClose(cs.w, 3, 0.01, 'Square 2â€³ + Â½â€³ seam = 3â€³ cut');

section('âœ‚ï¸ cutSize â€” Rectangle Piece');
cs = cutSize({ type: 'rect', finW: 6, finH: 3 }, 0.25);
assertClose(cs.w, 6.5, 0.01, 'Rect 6Ã—3â€³ width + seam = 6Â½â€³');
assertClose(cs.h, 3.5, 0.01, 'Rect 6Ã—3â€³ height + seam = 3Â½â€³');

section('âœ‚ï¸ cutSize â€” Half-Square Triangle');
cs = cutSize({ type: 'hst', finW: 3 }, 0.25);
assertClose(cs.w, 3.875, 0.01, 'HST 3â€³ finished â†’ 3â…â€³ cut (fin + â…)');
assert(cs.yieldsTwo === true, 'HST yields 2 triangles per square');

cs = cutSize({ type: 'hst', finW: 6 }, 0.25);
assertClose(cs.w, 6.875, 0.01, 'HST 6â€³ finished â†’ 6â…â€³ cut');

section('âœ‚ï¸ cutSize â€” Flying Geese');
cs = cutSize({ type: 'flygeese', finW: 6, finH: 3 }, 0.25);
assertClose(cs.w, 7.25, 0.01, 'FG large square: 6 + 1Â¼ = 7Â¼â€³');
assertClose(cs.smallW, 3.875, 0.01, 'FG small square: 3 + â… = 3â…â€³');
assert(cs.yieldsFour === true, 'FG yields 4 geese from large square');

section('âœ‚ï¸ cutSize â€” Quarter-Square Triangle');
cs = cutSize({ type: 'qst', finW: 6 }, 0.25);
assertClose(cs.w, 7.25, 0.01, 'QST 6â€³ finished â†’ 7Â¼â€³ cut (fin + 1Â¼)');
assert(cs.yieldsFour === true, 'QST yields 4 triangles per square');
cs = cutSize({ type: 'qst', finW: 3 }, 0.25);
assertClose(cs.w, 4.25, 0.01, 'QST 3â€³ finished â†’ 4Â¼â€³ cut');

section('âœ‚ï¸ cutSize â€” Strip Set');
cs = cutSize({ type: 'strip', finW: 10, finH: 2 }, 0.25);
assertClose(cs.w, 10.5, 0.01, 'Strip 10â€³ finished â†’ 10Â½â€³ sub-cut width');
assertClose(cs.h, 2.5, 0.01, 'Strip 2â€³ finished â†’ 2Â½â€³ strip height');
assert(cs.isStrip === true, 'Strip has isStrip flag');

section('âœ‚ï¸ cutSize â€” AppliquÃ© Circle');
cs = cutSize({ type: 'circle', finW: 6 }, 0.25);
assertClose(cs.w, 6.75, 0.01, 'Circle 6â€³ finished â†’ 6Â¾â€³ cut square (fin + Â¾)');
cs = cutSize({ type: 'circle', finW: 3 }, 0.25);
assertClose(cs.w, 3.75, 0.01, 'Circle 3â€³ finished â†’ 3Â¾â€³ cut square');

section('ğŸ”² Grid Calculation');
let g = calcGrid(50, 65, 12, 0, 0);
assertEq(g.cols, 4, 'Throw (50Ã—65), 12â€³ block, no border/sash â†’ 4 cols');
assertEq(g.rows, 5, 'Throw (50Ã—65), 12â€³ block â†’ 5 rows');
assertEq(g.total, 20, '4Ã—5 = 20 blocks');

g = calcGrid(50, 65, 12, 3, 0);
assertEq(g.cols, 3, '50â€³ - 6â€³ border = 44â€³ inner â†’ 3 cols of 12â€³');
assertEq(g.rows, 4, '65â€³ - 6â€³ border = 59â€³ inner â†’ 4 rows of 12â€³');

g = calcGrid(50, 65, 9, 1.5, 1.5);
assertEq(g.cols, 4, '50â€³ / (9+1.5) = 4.76 â†’ 4 cols with sashing');

g = calcGrid(36, 52, 12, 0, 0);
assertEq(g.cols, 3, 'Baby (36Ã—52), 12â€³ â†’ 3 cols');
assertEq(g.rows, 4, 'Baby â†’ 4 rows');
assertEq(g.total, 12, '3Ã—4 = 12 blocks');

g = calcGrid(105, 96, 12, 4, 2);
assertEq(g.cols, 7, 'King (105Ã—96), 12â€³ block, 4â€³ border, 2â€³ sash â†’ 7 cols');
assertEq(g.rows, 6, 'King â†’ 6 rows');

section('ğŸ“¦ Strip Calculation (pieces per WOF)');
assertEq(calcStripsNeeded(10, 3.5, 42), 1, '10 Ã— 3Â½â€³ pieces across 42â€³ WOF = 12 per strip â†’ 1 strip');
assertEq(calcStripsNeeded(13, 3.5, 42), 2, '13 pieces â†’ need 2 strips');
assertEq(calcStripsNeeded(24, 3.5, 42), 2, '24 pieces across 42â€³ (12/strip) â†’ 2 strips');
assertEq(calcStripsNeeded(25, 3.5, 42), 3, '25 pieces â†’ 3 strips');
assertEq(calcStripsNeeded(4, 50, 42), 4, '50â€³ piece wider than 42â€³ WOF â†’ 1 per strip â†’ 4 strips');
assertEq(calcStripsNeeded(1, 42, 42), 1, 'Exactly WOF width â†’ 1 strip');

section('ğŸ§µ Binding Calculation');
assertEq(calcBinding(50, 65, 42, 2.5), 6, 'Throw perimeter = 2(50+65)+12 = 242â€³ â†’ 242/42 = 6 strips');
assertEq(calcBinding(105, 96, 42, 2.5), 10, 'King perimeter = 2(105+96)+12 = 414â€³ â†’ 10 strips');
assertEq(calcBinding(36, 52, 42, 2.5), 5, 'Baby perimeter = 2(36+52)+12 = 188â€³ â†’ 5 strips');

section('ğŸ”™ Backing Calculation');
let bk = calcBacking(50, 65, 42);
assert(bk >= 2, 'Throw backing â‰¥ 2 yards');
assertClose(bk, Math.ceil(((73 * 2) / 36) * 8) / 8, 0.01, 'Throw: 58â€³ wide (>42) â†’ 2 panels Ã— 73â€³');

bk = calcBacking(36, 52, 42);
assertClose(bk, Math.ceil((60 / 36) * 8) / 8, 0.01, 'Baby: 44â€³ wide (>42) â†’ 2 panels Ã— 60â€³');

bk = calcBacking(30, 40, 42);
assertClose(bk, Math.ceil((48 / 36) * 8) / 8, 0.01, 'Small quilt: 38â€³ wide (â‰¤42) â†’ 1 panel Ã— 48â€³');

section('ğŸ§® Full Yardage Scenario â€” Nine Patch Throw');
{
  const blockSz = 9, seam = 0.25, wof = 42, sashW = 1.5, borderW = 3;
  const gr = calcGrid(50, 65, blockSz, borderW, sashW);
  // Nine patch: 5 blue squares + 4 cream squares, each 3â€³ finished
  const blueCS = cutSize({ type: 'square', finW: 3 }, seam);
  const blueTotal = 5 * gr.total;
  const blueStrips = calcStripsNeeded(blueTotal, blueCS.w, wof);
  const blueInches = blueStrips * blueCS.h;
  assert(blueCS.w === 3.5, 'Blue cut size = 3Â½â€³');
  assert(blueTotal > 0, `Total blue pieces = ${blueTotal}`);
  assert(blueStrips > 0, `Blue strips needed = ${blueStrips}`);
  assert(blueInches > 0, `Blue fabric inches = ${blueInches}`);
  const blueYards = blueInches / 36;
  assert(blueYards < 5, `Blue yardage (${blueYards.toFixed(2)}) should be reasonable for a throw`);
}

section('ğŸ§® Full Yardage Scenario â€” HST Pinwheel');
{
  const blockSz = 12, seam = 0.25, wof = 42;
  const gr = calcGrid(60, 72, blockSz, 4, 2);
  // 4 HSTs per block, 6â€³ finished
  const hstCS = cutSize({ type: 'hst', finW: 6 }, seam);
  const totalHSTs = 4 * gr.total;
  const squaresNeeded = Math.ceil(totalHSTs / 2);
  assertClose(hstCS.w, 6.875, 0.01, 'HST 6â€³ â†’ 6â…â€³ cut');
  assert(squaresNeeded === totalHSTs / 2, `Need ${squaresNeeded} squares for ${totalHSTs} HSTs`);
  const strips = calcStripsNeeded(squaresNeeded, hstCS.w, wof);
  assert(strips > 0, `HST strips = ${strips}`);
}

section('ğŸ§® Edge Cases');
{
  // Zero seam allowance
  const cs0 = cutSize({ type: 'square', finW: 5 }, 0);
  assertEq(cs0.w, 5, 'Zero seam â†’ cut = finished size');

  // Very large seam allowance
  const csLg = cutSize({ type: 'square', finW: 3 }, 1);
  assertEq(csLg.w, 5, '1â€³ seam â†’ 3 + 2(1) = 5â€³ cut');

  // Single block quilt
  const g1 = calcGrid(12, 12, 12, 0, 0);
  assertEq(g1.total, 1, '12Ã—12â€³ quilt with 12â€³ block = 1 block');

  // Block larger than quilt (should clamp to 1)
  const gBig = calcGrid(10, 10, 15, 0, 0);
  assertEq(gBig.total, 1, 'Block bigger than quilt â†’ at least 1 block');

  // Very small HST
  const csSmall = cutSize({ type: 'hst', finW: 1 }, 0.25);
  assertClose(csSmall.w, 1.875, 0.01, '1â€³ HST â†’ 1â…â€³ cut');
}

section('ğŸ“Š Yardage Rounding Edge Cases');
assertEq(yardsToFraction(0.124), 'â…›', 'Just under â…› rounds up to â…›');
assertEq(yardsToFraction(0.126), 'Â¼', 'Just over â…› rounds up to Â¼');
assertEq(yardsToFraction(0.251), 'â…œ', 'Just over Â¼ rounds up to â…œ');
assertEq(yardsToFraction(3.01), '3 â…›', '3.01 â†’ 3â…› (rounds up)');
assertEq(yardsToFraction(0.875), 'â…', 'â… yard exact');
assertEq(yardsToFraction(0.876), '1', 'Just over â… rounds up to 1');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SUMMARY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const total = passed + failed;
out.innerHTML += `<div class="summary ${failed === 0 ? 'ok' : 'bad'}">
  ğŸ“Š ${passed}/${total} tests passed${failed > 0 ? ` â€” ${failed} FAILED` : ' â€” ALL PASSED! ğŸ‰'}
</div>`;
</script>
</body>
</html>
